#!/bin/bash
# Shell hook for lazy-wrappers
# This runs after each command and removes wrapper directories from PATH
# once the corresponding version manager has been loaded, replacing them
# with the actual version manager paths

# Resolve paths dynamically from this script's location
# shell-hook lives at <install_dir>/scripts/shell-hook
if [[ -n "${BASH_SOURCE[0]:-}" ]]; then
    _LW_HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
else
    # zsh: $0 is the sourced file path when sourcing
    _LW_HOOK_DIR="$(cd "$(dirname "$0")" && pwd)"
fi
_LW_NODE_DIR="$_LW_HOOK_DIR/bin/node_wrappers"
_LW_RUBY_DIR="$_LW_HOOK_DIR/bin/ruby_wrappers"

# Use flag files to track which version managers have been loaded
_LW_FLAGS_DIR="${XDG_RUNTIME_DIR:-/tmp}/lazy-wrappers-$$"

__lazy_wrappers_load_nvm_into_parent_shell() {
    export NVM_DIR="${NVM_DIR:-$HOME/.nvm}"

    if [[ ! -s "$NVM_DIR/nvm.sh" ]]; then
        return 0
    fi

    # shellcheck source=/dev/null
    . "$NVM_DIR/nvm.sh"

    if [[ -s "$NVM_DIR/bash_completion" ]]; then
        # zsh needs bashcompinit for bash-style completion scripts.
        if [[ -n "${ZSH_VERSION:-}" ]] && ! type complete >/dev/null 2>&1; then
            autoload -Uz bashcompinit 2>/dev/null || true
            bashcompinit 2>/dev/null || true
        fi

        if type complete >/dev/null 2>&1; then
            # shellcheck source=/dev/null
            . "$NVM_DIR/bash_completion"
        fi
    fi

    export NVM_ALREADY_LOADED=1
}

__lazy_wrappers_load_rbenv_into_parent_shell() {
    export RBENV_DIR="${RBENV_DIR:-$HOME/.rbenv}"
    if [[ ! -x "$RBENV_DIR/bin/rbenv" ]]; then
        return 0
    fi

    if [[ -n "${ZSH_VERSION:-}" ]]; then
        eval "$("$RBENV_DIR/bin/rbenv" init - zsh)"

        # rbenv's zsh completion needs the completions directory on fpath.
        if [[ -d "$RBENV_DIR/completions" ]]; then
            __lazy_wrappers_has_rbenv_completion_path=0
            for __path in "${fpath[@]}"; do
                if [[ "$__path" == "$RBENV_DIR/completions" ]]; then
                    __lazy_wrappers_has_rbenv_completion_path=1
                    break
                fi
            done

            if [[ "$__lazy_wrappers_has_rbenv_completion_path" -eq 0 ]]; then
                fpath=("$RBENV_DIR/completions" "${fpath[@]}")
            fi

            autoload -Uz _rbenv 2>/dev/null || true
            type compdef >/dev/null 2>&1 && compdef _rbenv rbenv 2>/dev/null || true
            unset __lazy_wrappers_has_rbenv_completion_path __path
        fi
    elif [[ -n "${BASH_VERSION:-}" ]]; then
        eval "$("$RBENV_DIR/bin/rbenv" init - bash)"
    else
        eval "$("$RBENV_DIR/bin/rbenv" init -)"
    fi

    export RBENV_ALREADY_LOADED=1
}

__lazy_wrappers_cleanup() {
    # Remove node_wrappers from PATH and load nvm into this shell if flag exists
    if [[ -f "$_LW_FLAGS_DIR/nvm_loaded" && "$PATH" == *"node_wrappers"* ]]; then
        PATH=":$PATH:"
        while [[ "$PATH" == *":$_LW_NODE_DIR:"* ]]; do
            PATH="${PATH//:$_LW_NODE_DIR:/:}"
        done
        PATH="${PATH#:}"
        PATH="${PATH%:}"
        # Load nvm into this shell if not already loaded
        if [[ -z "${NVM_ALREADY_LOADED:-}" ]]; then
            __lazy_wrappers_load_nvm_into_parent_shell
        fi
        export PATH
    fi
    
    # Remove ruby_wrappers from PATH and load rbenv into this shell if flag exists
    if [[ -f "$_LW_FLAGS_DIR/rbenv_loaded" && "$PATH" == *"ruby_wrappers"* ]]; then
        PATH=":$PATH:"
        while [[ "$PATH" == *":$_LW_RUBY_DIR:"* ]]; do
            PATH="${PATH//:$_LW_RUBY_DIR:/:}"
        done
        PATH="${PATH#:}"
        PATH="${PATH%:}"
        # Load rbenv into this shell if not already loaded
        if [[ -z "${RBENV_ALREADY_LOADED:-}" ]]; then
            __lazy_wrappers_load_rbenv_into_parent_shell
        fi
        export PATH
    fi
}

__lazy_wrappers_cleanup_flags_dir() {
    rm -rf "$_LW_FLAGS_DIR" 2>/dev/null || true
}

__lazy_wrappers_install_bash_exit_cleanup() {
    local trap_output=""
    local existing_exit_trap=""

    trap_output="$(trap -p EXIT 2>/dev/null || true)"
    if [[ -n "$trap_output" ]]; then
        existing_exit_trap="${trap_output#trap -- \'}"
        existing_exit_trap="${existing_exit_trap%\' EXIT}"
    fi

    if [[ "$existing_exit_trap" == *"__lazy_wrappers_cleanup_flags_dir"* ]]; then
        return 0
    fi

    if [[ -n "$existing_exit_trap" ]]; then
        trap "__lazy_wrappers_cleanup_flags_dir; $existing_exit_trap" EXIT
    else
        trap "__lazy_wrappers_cleanup_flags_dir" EXIT
    fi
}

# Create the flags directory for this shell session
mkdir -p "$_LW_FLAGS_DIR" 2>/dev/null

# Install the hook based on shell type
if [[ -n "${ZSH_VERSION:-}" ]]; then
    # Zsh: use precmd hook
    autoload -Uz add-zsh-hook
    add-zsh-hook precmd __lazy_wrappers_cleanup
    add-zsh-hook zshexit __lazy_wrappers_cleanup_flags_dir
elif [[ -n "${BASH_VERSION:-}" ]]; then
    # Bash: use PROMPT_COMMAND
    if [[ "${PROMPT_COMMAND:-}" != *"__lazy_wrappers_cleanup"* ]]; then
        PROMPT_COMMAND="__lazy_wrappers_cleanup${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
    fi
    __lazy_wrappers_install_bash_exit_cleanup
else
    trap "__lazy_wrappers_cleanup_flags_dir" EXIT
fi

# Export the flags dir so wrappers can use it
export _LW_FLAGS_DIR
