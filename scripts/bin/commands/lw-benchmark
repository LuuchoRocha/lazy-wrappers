#!/bin/bash
# lw-benchmark: Comprehensive benchmark for lazy-wrappers
# Tests both shell startup time AND per-command overhead
# This script lives at <install_dir>/scripts/bin/commands/

set -euo pipefail

# Resolve paths relative to this script's location
SCRIPT_SOURCE_DIR="$(cd "$(dirname "$0")" && pwd)"
INSTALL_DIR="$(cd "$SCRIPT_SOURCE_DIR/../../.." && pwd)"

ITERATIONS="${1:-100}"
SHELL_TO_TEST="${SHELL:-/bin/bash}"
SHELL_NAME="$(basename "$SHELL_TO_TEST")"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Paths
LAZY_WRAPPERS_DIR="$INSTALL_DIR"
NODE_WRAPPERS="$LAZY_WRAPPERS_DIR/scripts/bin/node_wrappers"
RUBY_WRAPPERS="$LAZY_WRAPPERS_DIR/scripts/bin/ruby_wrappers"
NVM_DIR="${NVM_DIR:-$HOME/.nvm}"
RBENV_DIR="${RBENV_DIR:-$HOME/.rbenv}"

# Output file
RESULTS_FILE="benchmark-results.md"
true > "$RESULTS_FILE"

# Function to print to both terminal and file
out() {
    echo -e "$1"
    # Strip ANSI codes for markdown file
    echo -e "$1" | sed 's/\x1b\[[0-9;]*m//g' >> "$RESULTS_FILE"
}

# Function to write only to file (for markdown-specific formatting)
md() {
    echo -e "$1" >> "$RESULTS_FILE"
}

# Check prerequisites
if [[ ! -d "$LAZY_WRAPPERS_DIR/scripts" ]]; then
    echo -e "${RED}Error: lazy-wrappers not installed. Run ./install.sh first.${NC}"
    exit 1
fi

out ""
md "# ğŸš€ lazy-wrappers Benchmark Results"
md ""
md "![Generated](https://img.shields.io/badge/Generated-$(date '+%Y--%-m--%-d')-blue)"
md ""

echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${BLUE}â•‘            ${BOLD}lazy-wrappers Comprehensive Benchmark${NC}${BLUE}               â•‘${NC}"
echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""

md "## System Information"
md ""
md "| Property | Value |"
md "|----------|-------|"
md "| Shell | \`$SHELL_TO_TEST\` |"
md "| Iterations | $ITERATIONS per test |"
md "| Date | $(date '+%Y-%m-%d %H:%M:%S') |"
md ""

echo -e "  Shell:       ${CYAN}$SHELL_TO_TEST${NC}"
echo -e "  Iterations:  ${CYAN}$ITERATIONS${NC} per test"
echo -e "  Date:        ${CYAN}$(date '+%Y-%m-%d %H:%M:%S')${NC}"
echo ""

# Create temp dir for RC files
TEMP_DIR=$(mktemp -d)
trap 'rm -rf "$TEMP_DIR"' EXIT

# ============================================================================
# Helper Functions
# ============================================================================

measure_startup() {
    local rc_file="$1"
    local total=0
    local times=()
    
    for ((i=1; i<=ITERATIONS; i++)); do
        if [[ "$SHELL_NAME" == "bash" ]]; then
            start=$(date +%s%N)
            "$SHELL_TO_TEST" --rcfile "$rc_file" -i -c "exit" 2>/dev/null
            end=$(date +%s%N)
        else
            start=$(date +%s%N)
            ZDOTDIR="$(dirname "$rc_file")" "$SHELL_TO_TEST" -i -c "exit" 2>/dev/null
            end=$(date +%s%N)
        fi
        elapsed=$(( (end - start) / 1000000 ))
        times+=("$elapsed")
        total=$((total + elapsed))
    done
    
    local avg=$((total / ITERATIONS))
    local min=${times[0]} max=${times[0]}
    for t in "${times[@]}"; do
        ((t < min)) && min=$t
        ((t > max)) && max=$t
    done
    echo "$avg $min $max"
}

measure_command() {
    local cmd="$1"
    local total=0
    local times=()
    
    for ((i=1; i<=ITERATIONS; i++)); do
        start=$(date +%s%N)
        $cmd --version &>/dev/null 2>&1 || true
        end=$(date +%s%N)
        elapsed=$(( (end - start) / 1000000 ))
        times+=("$elapsed")
        total=$((total + elapsed))
    done
    
    local avg=$((total / ITERATIONS))
    local min=${times[0]} max=${times[0]}
    for t in "${times[@]}"; do
        ((t < min)) && min=$t
        ((t > max)) && max=$t
    done
    echo "$avg $min $max"
}

find_real_binary() {
    local name="$1"
    local wrapper_dir="$2"
    local clean_path="${PATH//$wrapper_dir:/}"
    clean_path="${clean_path//:$wrapper_dir/}"
    PATH="$clean_path" command -v "$name" 2>/dev/null || echo ""
}

# ============================================================================
# PART 1: Shell Startup Time
# ============================================================================

echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
echo -e "${BLUE}â”‚  ${BOLD}PART 1: Shell Startup Time${NC}${BLUE}                                       â”‚${NC}"
echo -e "${BLUE}â”‚  How long does it take to open a new terminal?                  â”‚${NC}"
echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
echo ""

md "## â±ï¸ Part 1: Shell Startup Time"
md ""
md "> How long does it take to open a new terminal?"
md ""

TEMP_RC="$TEMP_DIR/.bashrc"
[[ "$SHELL_NAME" == "zsh" ]] && TEMP_RC="$TEMP_DIR/.zshrc"

# Baseline
echo -ne "  ${YELLOW}[1/4]${NC} Baseline (no version managers)...        "
cat > "$TEMP_RC" << 'EOF'
export PATH="/usr/local/bin:/usr/bin:/bin"
EOF
read -r baseline_avg baseline_min baseline_max <<< "$(measure_startup "$TEMP_RC")"
echo -e "${GREEN}${baseline_avg}ms${NC}"

# Traditional nvm
nvm_avg=0 nvm_savings=0
if [[ -s "$NVM_DIR/nvm.sh" ]]; then
    echo -ne "  ${YELLOW}[2/4]${NC} Traditional nvm loading...              "
    cat > "$TEMP_RC" << EOF
export NVM_DIR="$NVM_DIR"
[ -s "\$NVM_DIR/nvm.sh" ] && . "\$NVM_DIR/nvm.sh"
[ -s "\$NVM_DIR/bash_completion" ] && . "\$NVM_DIR/bash_completion"
EOF
    read -r nvm_avg nvm_min nvm_max <<< "$(measure_startup "$TEMP_RC")"
    echo -e "${RED}${nvm_avg}ms${NC} (+$((nvm_avg - baseline_avg))ms)"
else
    echo -e "  ${YELLOW}[2/4]${NC} Traditional nvm loading...              ${YELLOW}skipped${NC} (not installed)"
fi

# Traditional rbenv
rbenv_avg=0 rbenv_savings=0
if [[ -x "$RBENV_DIR/bin/rbenv" ]]; then
    echo -ne "  ${YELLOW}[3/4]${NC} Traditional rbenv loading...            "
    cat > "$TEMP_RC" << EOF
export PATH="$RBENV_DIR/bin:\$PATH"
eval "\$($RBENV_DIR/bin/rbenv init - $SHELL_NAME)"
EOF
    read -r rbenv_avg rbenv_min rbenv_max <<< "$(measure_startup "$TEMP_RC")"
    echo -e "${RED}${rbenv_avg}ms${NC} (+$((rbenv_avg - baseline_avg))ms)"
else
    echo -e "  ${YELLOW}[3/4]${NC} Traditional rbenv loading...            ${YELLOW}skipped${NC} (not installed)"
fi

# lazy-wrappers
echo -ne "  ${YELLOW}[4/4]${NC} lazy-wrappers...                        "
cat > "$TEMP_RC" << EOF
export PATH="$NODE_WRAPPERS:$RUBY_WRAPPERS:\$PATH"
. "$LAZY_WRAPPERS_DIR/scripts/shell_hook.sh"
EOF
read -r lazy_avg lazy_min lazy_max <<< "$(measure_startup "$TEMP_RC")"
echo -e "${GREEN}${lazy_avg}ms${NC} (+$((lazy_avg - baseline_avg))ms)"

echo ""
printf "  ${BOLD}%-32s %8s %8s %8s${NC}\n" "Configuration" "Avg" "Min" "Max"
printf "  %-32s %8s %8s %8s\n" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€"
printf "  %-32s %6dms %6dms %6dms\n" "Baseline (no managers)" "$baseline_avg" "$baseline_min" "$baseline_max"
[[ $nvm_avg -gt 0 ]] && printf "  %-32s %6dms %6dms %6dms\n" "Traditional nvm" "$nvm_avg" "$nvm_min" "$nvm_max"
[[ $rbenv_avg -gt 0 ]] && printf "  %-32s %6dms %6dms %6dms\n" "Traditional rbenv" "$rbenv_avg" "$rbenv_min" "$rbenv_max"
printf "  %-32s %6dms %6dms %6dms\n" "lazy-wrappers" "$lazy_avg" "$lazy_min" "$lazy_max"

# Write markdown table
md "| Configuration | Avg | Min | Max |"
md "|:--------------|----:|----:|----:|"
md "| âšª Baseline (no managers) | ${baseline_avg}ms | ${baseline_min}ms | ${baseline_max}ms |"
[[ $nvm_avg -gt 0 ]] && md "| ğŸ”´ Traditional nvm | ${nvm_avg}ms | ${nvm_min}ms | ${nvm_max}ms |"
[[ $rbenv_avg -gt 0 ]] && md "| ğŸŸ  Traditional rbenv | ${rbenv_avg}ms | ${rbenv_min}ms | ${rbenv_max}ms |"
md "| ğŸŸ¢ **lazy-wrappers** | **${lazy_avg}ms** | ${lazy_min}ms | ${lazy_max}ms |"
md ""

# Calculate savings
startup_savings=0
if [[ $nvm_avg -gt 0 ]]; then
    nvm_savings=$((nvm_avg - lazy_avg))
    startup_savings=$nvm_savings
    nvm_pct=$(( (nvm_savings * 100) / nvm_avg ))
    echo ""
    echo -e "  ${GREEN}âœ“${NC} vs nvm:   ${GREEN}-${nvm_savings}ms${NC} (${GREEN}${nvm_pct}% faster${NC})"
    md "ğŸŸ¢ **vs nvm:** -${nvm_savings}ms (${nvm_pct}% faster)"
fi
if [[ $rbenv_avg -gt 0 ]]; then
    rbenv_savings=$((rbenv_avg - lazy_avg))
    [[ $startup_savings -eq 0 ]] && startup_savings=$rbenv_savings
    rbenv_pct=$(( (rbenv_savings * 100) / rbenv_avg ))
    echo -e "  ${GREEN}âœ“${NC} vs rbenv: ${GREEN}-${rbenv_savings}ms${NC} (${GREEN}${rbenv_pct}% faster${NC})"
    md "ğŸŸ¢ **vs rbenv:** -${rbenv_savings}ms (${rbenv_pct}% faster)"
fi
md ""

# ============================================================================
# PART 2: Per-Command Overhead
# ============================================================================

echo ""
echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
echo -e "${BLUE}â”‚  ${BOLD}PART 2: First-Command Overhead${NC}${BLUE}                                   â”‚${NC}"
echo -e "${BLUE}â”‚  One-time cost when wrapper triggers version manager load       â”‚${NC}"
echo -e "${BLUE}â”‚  (Subsequent commands bypass wrappers entirely - zero overhead) â”‚${NC}"
echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
echo ""

md "## âš¡ Part 2: First-Command Overhead"
md ""
md "*One-time cost when wrapper triggers version manager load. Subsequent commands bypass wrappers entirely â€” **zero overhead**.*"
md ""

# Ensure version managers are loaded
export NVM_DIR="${NVM_DIR:-$HOME/.nvm}"
[[ -s "$NVM_DIR/nvm.sh" ]] && . "$NVM_DIR/nvm.sh" &>/dev/null
export NVM_ALREADY_LOADED=1

export RBENV_DIR="${RBENV_DIR:-$HOME/.rbenv}"
if [[ -x "$RBENV_DIR/bin/rbenv" ]]; then
    eval "$("$RBENV_DIR/bin/rbenv" init - bash)" &>/dev/null
    export RBENV_ALREADY_LOADED=1
fi

printf "  ${BOLD}%-12s %10s %10s %10s %10s${NC}\n" "Binary" "Wrapper" "Direct" "Overhead" "Pct"
printf "  %-12s %10s %10s %10s %10s\n" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

md "| Binary | Wrapper | Direct | Overhead |"
md "|:-------|--------:|-------:|---------:|"

total_overhead=0
count=0

# Test binaries
for binary in node npm npx ruby gem bundle; do
    if [[ "$binary" =~ ^(node|npm|npx)$ ]]; then
        wrapper="$NODE_WRAPPERS/$binary"
        real=$(find_real_binary "$binary" "$NODE_WRAPPERS")
    else
        wrapper="$RUBY_WRAPPERS/$binary"
        real=$(find_real_binary "$binary" "$RUBY_WRAPPERS")
    fi
    
    if [[ -f "$wrapper" && -n "$real" ]]; then
        read -r wrap_avg _ _ <<< "$(measure_command "$wrapper")"
        read -r real_avg _ _ <<< "$(measure_command "$real")"
        
        overhead=$((wrap_avg - real_avg))
        total_overhead=$((total_overhead + overhead))
        ((count++)) || true
        
        if [[ $real_avg -gt 0 ]]; then
            overhead_pct=$(( (overhead * 100) / real_avg ))
        else
            overhead_pct=0
        fi
        
        if [[ $overhead -gt 5 ]]; then
            color=$YELLOW
        elif [[ $overhead -gt 0 ]]; then
            color=$GREEN
        else
            color=$GREEN
        fi
        
        printf "  %-12s %8dms %8dms ${color}%+8dms %+8d%%${NC}\n" \
            "$binary" "$wrap_avg" "$real_avg" "$overhead" "$overhead_pct"
        
        # Choose emoji based on overhead
        if [[ $overhead -le 1 ]]; then
            overhead_emoji="ğŸŸ¢"
        elif [[ $overhead -le 3 ]]; then
            overhead_emoji="ğŸŸ¡"
        else
            overhead_emoji="ğŸŸ "
        fi
        md "| \`$binary\` | ${wrap_avg}ms | ${real_avg}ms | ${overhead_emoji} +${overhead}ms |"
    fi
done

md ""

# Calculate average overhead
if [[ $count -gt 0 ]]; then
    avg_overhead=$((total_overhead / count))
else
    avg_overhead=1
fi
[[ $avg_overhead -le 0 ]] && avg_overhead=1

# ============================================================================
# PART 3: Analysis
# ============================================================================

echo ""
echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
echo -e "${BLUE}â”‚  ${BOLD}PART 3: Break-Even Analysis${NC}${BLUE}                                      â”‚${NC}"
echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
echo ""

md "## ğŸ“Š Part 3: Break-Even Analysis"
md ""

echo -e "  Shell startup savings:      ${GREEN}${startup_savings}ms${NC}"
echo -e "  First-command overhead:     ${YELLOW}${avg_overhead}ms${NC} (one-time, then wrappers removed)"
echo -e "  Subsequent commands:        ${GREEN}0ms overhead${NC} (direct binary execution)"
echo ""
echo -e "  ${BOLD}Verdict:${NC}"
echo -e "  ${GREEN}âœ“${NC} lazy-wrappers is beneficial for virtually all workflows"
echo -e "    After the first command, wrappers are removed from PATH"
echo -e "    All subsequent commands run at full native speed"

md "| Metric | Value |"
md "|:-------|------:|"
md "| ğŸŸ¢ Shell startup savings | **${startup_savings}ms** |"
md "| ğŸŸ¡ First-command overhead | ${avg_overhead}ms *(one-time)* |"
md "| ğŸŸ¢ Subsequent commands | **0ms** |"
md ""
md "**âœ… Verdict:** lazy-wrappers is beneficial for virtually all workflows. After the first command, wrappers are removed from PATH and all subsequent commands run at full native speed."
md ""

# ============================================================================
# Summary
# ============================================================================

echo ""
echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
echo -e "${BLUE}â”‚  ${BOLD}Summary${NC}${BLUE}                                                          â”‚${NC}"
echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
echo ""
echo -e "  ${GREEN}PROS:${NC}"
echo -e "    âœ“ Shell starts ~${startup_savings}ms faster"
echo -e "    âœ“ Version managers load only when needed"
echo -e "    âœ“ Multiple terminals don't each pay startup cost"
echo ""
echo -e "  ${RED}CONS:${NC}"
echo -e "    âœ— First command in session triggers version manager load"
echo -e "    âœ— ~${avg_overhead}ms one-time overhead on that first command"
echo ""
echo -e "  ${CYAN}BEST FOR:${NC}"
echo -e "    â€¢ Opening many terminal sessions"
echo -e "    â€¢ Quick shell commands before using node/ruby"
echo -e "    â€¢ Development with moderate node/ruby usage"
echo ""

md "## ğŸ“‹ Summary"
md ""
md "### ğŸŸ¢ Pros"
md ""
md "- âš¡ Shell starts **~${startup_savings}ms faster**"
md "- ğŸ’¤ Version managers load only when needed"
md "- ğŸªŸ Multiple terminals don't each pay startup cost"
md ""
md "### ğŸŸ¡ Cons"
md ""
md "- First command in session triggers version manager load"
md "- ~${avg_overhead}ms one-time overhead on that first command"
md ""
md "### ğŸ¯ Best For"
md ""
md "- Opening many terminal sessions"
md "- Quick shell commands before using node/ruby"
md "- Development with moderate node/ruby usage"
md ""
md "---"
md ""
md "*Run \`lw-benchmark\` to regenerate these results on your system.*"
md ""

echo -e "  Results saved to: ${CYAN}$RESULTS_FILE${NC}"
echo ""
